/// Problem 29: [Distinct powers](https://projecteuler.net/problem=29)

use crate::factorizer::NaiveFactorizer;
use crate::primes::Primes;
use itertools::Itertools;
use std::collections::HashMap;

pub struct Problem0029 { }

impl Problem0029 {
    /// Find the number of _distinct_ terms that are in the sequence
    /// generated by `a^b` for `2 ≤ a ≤ n` and `2 ≤ b ≤ n`.
    #[must_use]
    pub fn solve(n: u32) -> usize {
        let primes = Primes::new(n).unwrap();
        let factorizer = NaiveFactorizer::new(&primes).unwrap();
        let mut factors: Vec<HashMap<u32, usize>> = Vec::new();
        for a in 2..=n {
            let factors_a = factorizer.factorize(a).unwrap();
            for b in 2..=n {
                let mut factors_b: HashMap<u32, usize> = HashMap::new();
                for (&k, &v) in factors_a.iter() {
                    factors_b.insert(k, v * b as usize);
                }
                factors.push(factors_b);
            }
        }
        factors.iter()
            .map(|f| Self::factors_to_string(f))
            .sorted()
            .dedup()
            .count()
    }

    fn factors_to_string(f: &HashMap<u32, usize>) -> String {
        f.iter().sorted()  // important to iterate keys in order
            .map(|(k, v)| format!("{}^{}", k, v))
            .collect::<Vec<String>>()
            .join("+")
    }

    #[must_use]
    pub fn output() -> String {
        format!("Problem 29 answer is {}", Self::solve(100))
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_solve_example() {
        let answer = Problem0029::solve(5);
        assert_eq!(15, answer);
    }

    #[test]
    #[ignore]
    fn test_solve_problem() {
        let answer = Problem0029::solve(100);
        assert_eq!(9183, answer);
    }
}
